<html>
<body style='background-color:white;'>
	<canvas id='editor_canvas' width='2048' height='1024' style='position:absolute; left:0; top:0'></canvas>
	<label id='result' style='position:absolute; left:48; top:20; font-family:monospace; font-size:11px'>Use [W] and [S] to adjust tile altitude up or down, [X] to delete tile and [F] to download current level to file. </label>
	<!-- <input id='offsetfile' type='file' style='position:absolute; left:1096; top:580'> -->
	<input type='file' id='selectFiles' value='Import' style='position:absolute; left:48; top:580; font-family:monospace'  />
	<script>
		let image = new Image();
		image.src = '../Source/Artwork/level_tiles-table-48-48.png';

		let image_red = new Image();
		image_red.src = './level_tiles-table-48-48_red.png';

		// tile offset values
		let offset_value_data;
		let offset_values_loaded = false;

		// input button for loading file containing tile offset values
		document.getElementById('selectFiles').onchange = function() {
			var files = document.getElementById('selectFiles').files;
			console.log(files);
			if (files.length <= 0) {
				alert("no file selected")
				return false;
			}
			var fr = new FileReader();
			fr.onload = function (e) {
				console.log(e);
				offset_value_data = JSON.parse(e.target.result);
				console.log(offset_value_data.loadmessage);
				offset_values_loaded = true;
			}
			fr.readAsText(files.item(0));
		};

		const MAP_COLS = 32;
		const MAP_ROWS = 32;
	
		const GRID_SIZE  = 16;

		const SOURCE_TILE_WIDTH  = 48;
		const SOURCE_TILE_HEIGHT = 48;

		const SOURCE_IMAGE_WIDTH = 240;
		const SOURCE_IMAGE_HEIGHT = 240;

		const LEVEL_IMAGE_WIDTH = 1024;
		const LEVEL_IMAGE_HEIGHT = 512;

		const X_OFFSET = 48;
		const Y_OFFSET = 48;

		const SOURCE_IMAGE_XPOS = SOURCE_TILE_WIDTH * 23
		const SOURCE_IMAGE_YPOS = SOURCE_TILE_HEIGHT * 1

		const NONE = 0;

		// the level array containing all tiles
		let tile_array = new Array(MAP_COLS * MAP_ROWS); tile_array.fill(NONE);
		// the level array containing all altitude offsets
		let altitude_array = new Array(MAP_COLS * MAP_ROWS); altitude_array.fill(0);
		
		let selected_source_tile = NONE;
		let selected_target = [0,0];
		let selected_target_pos = [0,0];
		let target_area_flag = true;
		
		let canvas = document.getElementById('editor_canvas');
		let context = canvas.getContext('2d');

		// text field
		let text_field = document.createElement("TEXTAREA");
		draw_text_field(text_field);
		text_field.value = tile_array;

		canvas.addEventListener('click', on_mouse_click);
		canvas.addEventListener('mousemove', on_mouse_move);
		document.addEventListener('keydown', on_keydown);

		image.addEventListener('load', redraw_source_image);

	 	
		draw_iso_grid();

		function on_mouse_move(e) {
			let x = e.clientX;
			let y = e.clientY;

			// source
			context.clearRect(SOURCE_IMAGE_XPOS, SOURCE_IMAGE_YPOS, SOURCE_IMAGE_WIDTH, SOURCE_IMAGE_HEIGHT);
			redraw_source_image();			
			if ( x > SOURCE_IMAGE_XPOS && x < SOURCE_IMAGE_XPOS + SOURCE_IMAGE_WIDTH && y > SOURCE_IMAGE_YPOS && y < SOURCE_IMAGE_YPOS + SOURCE_IMAGE_HEIGHT ) {
				let gridx = SOURCE_IMAGE_XPOS + Math.floor( (x - SOURCE_IMAGE_XPOS) / SOURCE_TILE_WIDTH) * SOURCE_TILE_WIDTH;
 				let gridy = SOURCE_IMAGE_YPOS + Math.floor( (y - SOURCE_IMAGE_YPOS) / SOURCE_TILE_HEIGHT) * SOURCE_TILE_HEIGHT;
				context.beginPath();
				context.strokeStyle = 'lightsteelblue';
				context.rect( gridx+1, gridy+1, SOURCE_TILE_WIDTH-2, SOURCE_TILE_HEIGHT-2 )
				context.stroke();
			}



			// target
			//context.clearRect(X_OFFSET,Y_OFFSET,LEVEL_IMAGE_WIDTH,LEVEL_IMAGE_HEIGHT);
			//draw_iso_grid();
			draw_selected_box();
			redraw_all_target_tiles();

			if ( x > X_OFFSET && x < X_OFFSET + LEVEL_IMAGE_WIDTH && y > Y_OFFSET && y < Y_OFFSET + LEVEL_IMAGE_HEIGHT )  {
				let gx = x - X_OFFSET - LEVEL_IMAGE_WIDTH/2;
				let gy = y - Y_OFFSET;
				let isoxy = iso_to_grid(gx,gy);
				let ix = Math.floor(isoxy[0]/MAP_COLS);
				let iy = Math.floor(isoxy[1]/MAP_ROWS);
				if(ix>=0&&ix<MAP_COLS&&iy>=0&&iy<MAP_ROWS) {
					target_area_flag = true;
					// clear last tile with grey
					let gridxy = grid_to_iso(selected_target[0], selected_target[1]);
					let x16 = gridxy[0]*16;
					let y16 = gridxy[1]*16;
					draw_tile_outline(x16, y16, X_OFFSET + LEVEL_IMAGE_WIDTH / 2, Y_OFFSET + GRID_SIZE / 2, 'lightsteelblue', 2);

					// update selected tile:
					selected_target = [ix, iy];
					gridxy = grid_to_iso(ix,iy);
					x16 = gridxy[0]*16;
					y16 = gridxy[1]*16;
					selected_target_pos = [x16,y16];
					draw_tile_outline(x16, y16, X_OFFSET+LEVEL_IMAGE_WIDTH/2, Y_OFFSET+GRID_SIZE/2, 'red', 1);

					let index = iy * MAP_COLS + ix;
					if (tile_array[index] > 0) {
						draw_red_tile(tile_array[index],x16,y16);
					}

				} else {
					target_area_flag = false;
				}
			}
			

		}

		function on_mouse_click(e) {
			let x = e.clientX;
			let y = e.clientY;

			if (!offset_values_loaded) {
				alert("load offset values first");
				return;
			}

			// source
			if (
				x > SOURCE_IMAGE_XPOS &&
				x < SOURCE_IMAGE_XPOS + SOURCE_IMAGE_WIDTH &&
				y > SOURCE_IMAGE_YPOS &&
				y < SOURCE_IMAGE_YPOS + SOURCE_IMAGE_HEIGHT
			) {
				let cols = SOURCE_IMAGE_HEIGHT / SOURCE_TILE_HEIGHT;
				let rows = SOURCE_IMAGE_WIDTH / SOURCE_TILE_WIDTH;
				let gridx = Math.floor((x - SOURCE_IMAGE_XPOS) / SOURCE_TILE_WIDTH);
				let gridy = Math.floor((y - SOURCE_IMAGE_YPOS) / SOURCE_TILE_HEIGHT);
				selected_source_tile = ((gridy * cols) + gridx) + 1; // adding 1 as lua counts arrays from 1
				draw_selected_box();
			}

			// return if mouse is not in target area
			if(!target_area_flag) {return;}

			// target
			if (x > X_OFFSET && x < X_OFFSET + LEVEL_IMAGE_WIDTH && y > Y_OFFSET && y < Y_OFFSET + LEVEL_IMAGE_HEIGHT) {
				let i = selected_target[1] * MAP_COLS + selected_target[0];
				tile_array[i] = selected_source_tile;
				// reset altitude for new tile
				altitude_array[i] = 0;
				text_field.value = tile_array;
				context.clearRect(X_OFFSET, Y_OFFSET, LEVEL_IMAGE_WIDTH, LEVEL_IMAGE_HEIGHT);
				draw_iso_grid();
				redraw_all_target_tiles();
				draw_red_tile(tile_array[i], selected_target_pos[0], selected_target_pos[1]);
			}
		}

		function on_keydown(e) {
			switch (e.key) {
				case 'w':
					console.log('up');
					lift_current_tile();
					break;
				case 's':
					console.log('down');
					lower_current_tile();
					break;
				case 'x':
					console.log('delete');
					delete_tile();
					break;
				case 'f':
					console.log('save level')
					export_level_to_txt();
					break;
			}
		}

		function delete_tile() {
			if (!target_area_flag) { return; }
			let i = selected_target[1] * MAP_COLS + selected_target[0];
			tile_array[i] = 0;
			altitude_array[i] = 0;
			console.log('deleted tile at: ' + selected_target[0] + " x " + selected_target[1]);
			context.clearRect(X_OFFSET, Y_OFFSET, LEVEL_IMAGE_WIDTH, LEVEL_IMAGE_HEIGHT);
			draw_iso_grid();
			redraw_all_target_tiles();
			text_field.value = tile_array;
		}

		function lift_current_tile() {
			if (!target_area_flag) {return;}
			let i = selected_target[1] * MAP_COLS + selected_target[0];
			if (tile_array[i] == NONE) { return; }
			altitude_array[i] = altitude_array[i] + 8;
			//console.log("lift tile: " + i + " to: " + altitude_array[i]);
			context.clearRect(X_OFFSET, Y_OFFSET, LEVEL_IMAGE_WIDTH, LEVEL_IMAGE_HEIGHT);
			draw_iso_grid();
			redraw_all_target_tiles();
			//console.log("selected source tile: " + selected_source_tile);
			//alert("bug: selected source tile is the currently selected tile not the current mouse over tile!")
			draw_red_tile(tile_array[i], selected_target_pos[0], selected_target_pos[1]);
		}

		function get_current_level_dimensions() {
			let max_x = 0;
			let max_y = 0;
			for (let y = 0; y < MAP_COLS; y++) {
				for (let x = 0; x < MAP_ROWS; x++) {
					i = (y * MAP_ROWS) + x;
					if(tile_array[i] == NONE) { continue };
					if(max_x < x) {max_x = x};
					if(max_y < y) {max_y = y}; 
				}
			}
			return [max_x+1, max_y+1];
		}

		function get_cropped_array(crop_x, crop_y, arr) {
			if(arr.length != MAP_ROWS*MAP_COLS) {
				console.log("array to crop needs to be exact full level size");
				return;
			}
			crop_array = [];
			for (let y = 0; y < crop_y; y++) {
				for (let x = 0; x < crop_x; x++) {
					full_index = (y * MAP_ROWS) + x;
					cropped_index = (y * crop_x) + x;
					crop_array[cropped_index] = arr[full_index];
				}
			}
			return crop_array;
		}

		function clean_tiles(arr) {
			for(let i=0; i<arr.length; i++) {
				if(arr[i]==0) arr[i]=18;
			}
			return arr;
		}

		function lower_current_tile() {
			if (!target_area_flag) {return;}
			let i = selected_target[1] * MAP_COLS + selected_target[0];
			if(tile_array[i] == NONE) {return;}
			altitude_array[i] = altitude_array[i] - 8;
			//console.log("lower tile: " + i + " to: " + altitude_array[i]);
			context.clearRect(X_OFFSET, Y_OFFSET, LEVEL_IMAGE_WIDTH, LEVEL_IMAGE_HEIGHT);
			draw_iso_grid();
			redraw_all_target_tiles();
			//console.log("selected source tile: " + selected_source_tile);
			//alert("bug: selected source tile is the currently selected tile not the current mouse over tile!")
			draw_red_tile(tile_array[i], selected_target_pos[0], selected_target_pos[1]);
		}

		// source area
		function redraw_source_image() { 
			context.drawImage(image, SOURCE_IMAGE_XPOS, SOURCE_IMAGE_YPOS);
		}

		function draw_selected_box() {
			if(selected_source_tile == NONE) {return;}
			let rows = SOURCE_IMAGE_WIDTH / SOURCE_TILE_WIDTH;
			let cols = SOURCE_IMAGE_HEIGHT / SOURCE_TILE_HEIGHT;
			if(selected_source_tile > rows*cols) {return;}
			
			let st = selected_source_tile-1; // adjusting for lua array being 1-based.
			let x = (st % cols) * SOURCE_TILE_WIDTH + SOURCE_IMAGE_XPOS;
			let y = Math.floor(st / cols) * SOURCE_TILE_HEIGHT + SOURCE_IMAGE_YPOS;
			context.beginPath();
			context.strokeStyle = 'red';
			context.rect(x+1, y+1, SOURCE_TILE_WIDTH-2, SOURCE_TILE_HEIGHT-2);
			context.stroke();
		}

		// target area
		function draw_iso_grid() {
			draw_edge_limit(X_OFFSET, Y_OFFSET);
			let ix, iy;
			for (let y = 0; y < MAP_ROWS; y++) {
				for (let x = 0; x < MAP_COLS; x++) {
					ix = x - y;
					iy = Math.abs(x + y) / 2;
					draw_tile_outline(ix * GRID_SIZE, iy * GRID_SIZE, LEVEL_IMAGE_WIDTH / 2 + X_OFFSET, GRID_SIZE / 2 + Y_OFFSET, 'lightsteelblue', 2);
				}
			}
		}

		function redraw_all_target_tiles() {
			if (tile_array.length != MAP_ROWS * MAP_COLS) {
				console.log("tile array length does not match map size (rows*columns)");
				return;
			}

			let rows = SOURCE_IMAGE_WIDTH / SOURCE_TILE_WIDTH;
			let cols = SOURCE_IMAGE_HEIGHT / SOURCE_TILE_HEIGHT;

			for (let y=0; y<MAP_ROWS; y++) {
				for (let x=0; x<MAP_COLS; x++) {
					let i = y * MAP_COLS + x;
					if(tile_array[i] == 0) { continue; }

					let til = tile_array[i]-1; // adjusting for lua array being 1-based.
					let tile_offset_xy = get_tile_offset(til);

					let soux = (til % cols) * SOURCE_TILE_WIDTH //+ SOURCE_IMAGE_XPOS;
					let souy = Math.floor(til / cols) * SOURCE_TILE_HEIGHT //+ SOURCE_IMAGE_YPOS;

					let gridxy = grid_to_iso(x, y);
					let tarx = gridxy[0] * 16 + LEVEL_IMAGE_WIDTH/2 + X_OFFSET + tile_offset_xy[0];
					let tary = gridxy[1] * 16 + Y_OFFSET + tile_offset_xy[1] - altitude_array[i];
	
					context.drawImage(image, soux, souy, SOURCE_TILE_WIDTH, SOURCE_TILE_HEIGHT, tarx, tary, SOURCE_TILE_WIDTH, SOURCE_TILE_HEIGHT);
				}
			}
		}

		function draw_tile_outline(x,y,xo,yo,color,thickness) {
			x=x+xo;
			y=y+yo;
			context.beginPath();
			context.strokeStyle = color;
			context.lineWidth = thickness;
			context.moveTo(x-GRID_SIZE, y);
			context.lineTo(x,y-GRID_SIZE / 2);
			context.lineTo(x+GRID_SIZE, y);
			context.lineTo(x,y+GRID_SIZE / 2);
			context.lineTo(x-GRID_SIZE, y);
			context.stroke();
		}

		function draw_red_tile(t,x,y) {
			if (t == NONE) { return; }

			let index = selected_target[1] * MAP_COLS + selected_target[0];

			let rows = SOURCE_IMAGE_WIDTH / SOURCE_TILE_WIDTH;
			let cols = SOURCE_IMAGE_HEIGHT / SOURCE_TILE_HEIGHT;
			t = t-1;

		//	let st = selected_source_tile - 1; // adjusting for lua array being 1-based.
			let sx = (t % cols) * SOURCE_TILE_WIDTH;
			let sy = Math.floor(t / cols) * SOURCE_TILE_HEIGHT;
			
			let tile_offset_xy = get_tile_offset(t);
			x = x + LEVEL_IMAGE_WIDTH/2 + X_OFFSET + tile_offset_xy[0];
			y = y + Y_OFFSET + tile_offset_xy[1] - altitude_array[index];

			context.drawImage(image_red, sx, sy, SOURCE_TILE_WIDTH, SOURCE_TILE_HEIGHT, x, y, SOURCE_TILE_WIDTH, SOURCE_TILE_HEIGHT);
		}

		function get_tile_offset(t) {
			tox = offset_value_data.tiles[t].xoffset;
			toy = offset_value_data.tiles[t].yoffset;
			return [tox, toy];
		}

		function draw_edge_limit(x, y) {
			context.beginPath();
			context.strokeStyle = 'red';
			context.rect(x, y, LEVEL_IMAGE_WIDTH, LEVEL_IMAGE_HEIGHT);
			context.stroke();
		}

		// text field
		function draw_text_field(t) {
			document.body.appendChild(t);
			t.setAttribute("type", "text");
			t.style = "font-family:monospace;";
			t.style.position = 'absolute';
			t.style.left = SOURCE_IMAGE_XPOS + 'px';
			t.style.top = SOURCE_IMAGE_YPOS + SOURCE_IMAGE_HEIGHT + Y_OFFSET + 'px';
			t.style.width = SOURCE_IMAGE_WIDTH + 'px';
			t.style.height = X_OFFSET + LEVEL_IMAGE_HEIGHT - (SOURCE_IMAGE_YPOS + SOURCE_IMAGE_HEIGHT + Y_OFFSET) + 'px';
		}

		function iso_to_grid(x, y) {
			let gx = x + y * 2;
			let gy = y * 2 - x;
			return [gx, gy];
		}

		function grid_to_iso(x, y) {
			let ix = x - y;
			let iy = Math.abs(x + y) / 2;
			return [ix, iy]
		}

		function export_level_to_txt() {
			let dim = get_current_level_dimensions();
			console.log("exporting level of size: " + dim[0] + " x " + dim[1]);
			let til_arr = get_cropped_array(dim[0],dim[1], tile_array);
			til_arr = clean_tiles(til_arr);
			let alt_arr = get_cropped_array(dim[0], dim[1], altitude_array);
			const original_data = {
				levels: [
					{
						id: 1,
						name: "level 1",
						time: 30,
						w: dim[0],
						h: dim[1],
						tiles: til_arr,
						altitude: alt_arr
					}
				]
			};

			const a = document.createElement("a");
			json_string = JSON.stringify(original_data, null, 2);
			// clean up some newlines, spaces and add some tabs
			json_string = json_string.replace(/[\n\r\s]+/g, '');
			json_string = json_string.replace(/,\"/g, ',\n\"');
			json_string = json_string.replace(/\[\{/g, '\n\[\n\{\n');
			json_string = json_string.replace(/\}\]/g, '\n\}\n\]\n');
			json_string = json_string.replace(/\n\"/g, '\n\t\"');
			// create a downloadable file object
			a.href = URL.createObjectURL(new Blob([json_string], {
				type: "text/plain"
			}));

			a.setAttribute("download", "leveldata.txt");
			document.body.appendChild(a);
			a.click();
			document.body.removeChild(a);
		}
		
	</script>
</body>
</html>