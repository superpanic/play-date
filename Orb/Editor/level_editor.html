<html>
<body>
	<canvas id='editor_canvas' width='2048' height='1024' style='position:absolute; left:0; top:0'></canvas>
	<!-- <label id='result' style='position:absolute; left:0; top:550'>Click on the image at the bottom to select a tile, then click on the grid to draw.</label> -->
	<script>
		let image = new Image();
		image.src = '../Source/Artwork/level_tiles-table-48-48.png';
			
		const map_cols = 31;
		const map_rows = 31;
	
		const grid_size  = 16;

		const source_tile_width  = 48;
		const source_tile_height = 48;

		const source_image_width = 240;
		const source_image_height = 240;

		const level_image_width = 1024;
		const level_image_height = 512;

		const x_offset = 48;
		const y_offset = 48;

		const source_image_xpos = source_tile_width * 23
		const source_image_ypos = source_tile_height * 1

		const xy_iso_conversion = 2;

		const NONE = -1;

		let tiles = new Array(map_cols * map_rows);
		let altitudes = new Array(map_cols * map_rows);

		let selected_tile = NONE;
		
		let canvas = document.getElementById('editor_canvas');
		let context = canvas.getContext('2d');

		// text field
		let text_field = document.createElement("TEXTAREA");
		draw_text_field(text_field);
		//text_field.value = tiles;

		canvas.addEventListener('click', on_mouse_click);
		canvas.addEventListener('mousemove', on_mouse_move);
		document.addEventListener('keydown', on_keydown);

		image.addEventListener('load', redraw_source);

	 	draw_edge_limit(x_offset, y_offset);
		draw_iso_grid();

		function on_mouse_move(e) {
			let x = e.clientX;
			let y = e.clientY;
			// source
			context.clearRect(source_image_xpos, source_image_ypos, source_image_width, source_image_height);
			redraw_source();
			draw_selected_box()
			if ( x > source_image_xpos && x < source_image_xpos + source_image_width && y > source_image_ypos && y < source_image_ypos + source_image_height ) {
				let gridx = source_image_xpos + Math.floor( (x - source_image_xpos) / source_tile_width) * source_tile_width;
				let gridy = source_image_ypos + Math.floor( (y - source_image_ypos) / source_tile_height) * source_tile_height;
				context.beginPath();
				context.strokeStyle = 'lightsteelblue';
				context.rect( gridx+1, gridy+1, source_tile_width-2, source_tile_height-2 )
				context.stroke();	
			}
			// target
			if ( x > x_offset && x < x_offset + level_image_width && y > y_offset && y < y_offset + level_image_height )  {
				let gx = x - x_offset - level_image_width/2;
				let gy = y - y_offset;
				let isoxy = iso_to_grid(gx,gy);
				let ix = Math.floor(isoxy[0]/32)
				let iy = Math.floor(isoxy[1]/32)
				if(ix>=0&&ix<32&&iy>=0&&iy<32) {
					console.log(ix, iy);
					let gridxy = grid_to_iso(ix,iy);
					let x16 = gridxy[0]*16;
					let y16 = gridxy[1]*16;
					draw_tile_outline(x16, y16, x_offset+level_image_width/2, y_offset+grid_size/2, 'red');
				}
			}

		}

		function iso_to_grid(x, y) {
			let gx = x + y * 2;
			let gy = y * 2 - x;
			return [gx, gy];
		}

		function grid_to_iso(x, y) {
			let ix = x - y;
			let iy = Math.abs(x + y) / 2;
			return [ix, iy]
		}

		function on_mouse_click(e) {
			let x = e.clientX;
			let y = e.clientY;

			// source
			if (
				x > source_image_xpos &&
				x < source_image_xpos + source_image_width &&
				y > source_image_ypos &&
				y < source_image_ypos + source_image_height
			) {
				let rows = source_image_width / source_tile_width;
				let cols = source_image_height / source_tile_height;
				let gridx = Math.floor((x - source_image_xpos) / source_tile_width);
				let gridy = Math.floor((y - source_image_ypos) / source_tile_height);
				selected_tile = ((gridy * cols) + gridx) + 1; // adding 1 as lua counts arrays from 1
				console.log(selected_tile);
				draw_selected_box();
			}

			// target
			if (x > x_offset && x < x_offset + level_image_width && y > y_offset && y < y_offset + level_image_height) {
				console.log('target click')
			}
		}

		function on_keydown(e) {
			switch (e.key) {
				case 'w':
					console.log('up');
					break;
				case 's':
					console.log('down');
					break;
				case 'x':
					console.log('delete');
					break;
			}
		}

		// source area
		function redraw_source() { 
			context.drawImage(image, source_image_xpos, source_image_ypos);
		}

		function draw_selected_box() {
			if(selected_tile == NONE) {return;}
			let rows = source_image_width / source_tile_width;
			let cols = source_image_height / source_tile_height;
			if(selected_tile > rows*cols) {return;}
			
			let st = selected_tile-1; // adjusting for lua array being 1-based.

			let x = (st % rows) * source_tile_width + source_image_xpos;
			let y = Math.floor(st / cols) * source_tile_height + source_image_ypos;
			context.beginPath();
			context.strokeStyle = 'red';
			context.rect(x+1, y+1, source_tile_width-2, source_tile_height-2);
			context.stroke();
		}

		// target area
		function draw_iso_grid() {
			let ix, iy;
			for (let y = 0; y <= map_rows; y++) {
				for (let x = 0; x <= map_cols; x++) {
					ix = x - y;
					iy = Math.abs(x + y) / 2;
					draw_tile_outline(ix * grid_size, iy * grid_size, level_image_width / 2 + x_offset, grid_size / 2 + y_offset, 'lightsteelblue');
				}
			}
		}

		function draw_tile_outline(x,y,xo,yo,color) {
			x=x+xo;
			y=y+yo;
			context.beginPath();
			context.strokeStyle = color;
			context.moveTo(x-grid_size, y);
			context.lineTo(x,y-grid_size / 2);
			context.lineTo(x+grid_size, y);
			context.lineTo(x,y+grid_size / 2);
			context.lineTo(x-grid_size, y);
			context.stroke();
		}

		function draw_edge_limit(x, y) {
			context.beginPath();
			context.strokeStyle = 'red';
			context.rect(x, y, level_image_width, level_image_height);
			context.stroke();
		}

		// text field
		function draw_text_field(t) {
			document.body.appendChild(t);
			t.setAttribute("type", "text");
			t.style = "font-family:monospace;";
			t.style.position = 'absolute';
			t.style.left = source_image_xpos + 'px';
			t.style.top = source_image_ypos + source_image_height + y_offset + 'px';
			t.style.width = source_image_width + 'px';
			t.style.height = x_offset + level_image_height - (source_image_ypos + source_image_height + y_offset) + 'px';
		}
		



	</script>
</body>
</html>